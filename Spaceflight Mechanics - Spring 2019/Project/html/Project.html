
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Spaceflight Mechanics - Semester Project - Spring 2019</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-03-07"><meta name="DC.source" content="Project.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Spaceflight Mechanics - Semester Project - Spring 2019</h1><!--introduction--><p>Angles Only Orbit Determination of Unknown Object from a Known Satellite</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Administrative Remarks</a></li><li><a href="#2">Clearing figures and command line</a></li><li><a href="#3">Declaring constants</a></li><li><a href="#4">Measured angle values</a></li><li><a href="#5">Time vectors</a></li><li><a href="#6">Calculate position R at the three times of the known satellite from known satellite orbital parameters</a></li><li><a href="#7">Determining unit vectors from satellite to unknown object</a></li><li><a href="#8">Cross products among the direction cosine vectors</a></li><li><a href="#9">Computing the six scalar quantities</a></li><li><a href="#10">Calculating A and B</a></li><li><a href="#11">Calculating E</a></li><li><a href="#12">Calculating a, b, and c</a></li><li><a href="#13">Calculating the roots numerically</a></li><li><a href="#14">Calculating the Lagrange coefficients</a></li><li><a href="#15">Calculating position vector magnitudes from satellite to unknown object</a></li><li><a href="#16">Calculating position vectors from earth center to unknown object</a></li><li><a href="#17">Calculating velocity of unknown object</a></li><li><a href="#18">Method to improve accuracy of results taken from Curtis</a></li><li><a href="#19">Determing orbit elements of unknown object from r2 and v2</a></li><li><a href="#20">Plotting both orbits of known satellite and unknown object</a></li><li><a href="#21">Ouputting parameters to Command Line</a></li></ul></div><h2 id="1">Administrative Remarks</h2><pre class="codeinput"><span class="comment">%Author: Johnathan Corbin</span>
<span class="comment">%February 9, 2019</span>
<span class="comment">%--------------------------------------------------------------------------</span>
<span class="comment">%Assumptions made about the system:</span>
<span class="comment">% - The two body problem applies.</span>
<span class="comment">% - This system takes place around the Earth (u = 398600).</span>
<span class="comment">% - The Earth is a perfect sphere so as to ignore effects of precession.</span>
<span class="comment">% - I use the topocentric horizon reference frame on the spacecraft to</span>
<span class="comment">%    create the direction unit vectors to the unknown object from a given</span>
<span class="comment">%    altitude and azimuth angle seen from the spacecraft.</span>
<span class="comment">% - The timescale between angle measurements must be fairly small, think</span>
<span class="comment">%     several minutes, not hours.</span>
<span class="comment">% - The orbit of the satellite taking the measurements is known and that a</span>
<span class="comment">%      position vector can be made to that satellite at each instance when</span>
<span class="comment">%      an angle measurement is made.</span>
<span class="comment">% - Values of the estimated orbit are output at the end of the script, any</span>
<span class="comment">%      value that is a rotation value are in degrees, not radians.</span>
<span class="comment">% - When defininig the orbit of the known satellite, the satellite must be</span>
<span class="comment">%      in an elliptical orbit.</span>
<span class="comment">%--------------------------------------------------------------------------</span>
<span class="comment">%Derivations of the algorithm and some of the required functions were</span>
<span class="comment">%pulled from Orbital Mechanics for Engineering Students by Howard D.</span>
<span class="comment">%Curtis.</span>
<span class="comment">%--------------------------------------------------------------------------</span>
<span class="comment">%Required functions:</span>
<span class="comment">% f_and_g, improvement, kepler_E, kepler_U, orbit_elements,</span>
<span class="comment">% satellite, posroot, stumpC, stumpS</span>
<span class="comment">%--------------------------------------------------------------------------</span>
</pre><h2 id="2">Clearing figures and command line</h2><pre class="codeinput">clear, clc
close <span class="string">all</span>
</pre><h2 id="3">Declaring constants</h2><pre class="codeinput"><span class="keyword">global</span> u

u = 398600; <span class="comment">%gravitational parameter for earth</span>
r_earth = 6378; <span class="comment">%radius of earth</span>
deg_rad = pi / 180; <span class="comment">%converting degree to rad</span>
</pre><h2 id="4">Measured angle values</h2><pre class="codeinput">azimuth = [10, 89,  90] * deg_rad; <span class="comment">%Azimuth angle of unknown object at times</span>
altitude = [0, 20, 40] * deg_rad; <span class="comment">%Altitude angle of unkown object at times</span>
</pre><h2 id="5">Time vectors</h2><pre class="codeinput">t = [0, 5*60, 10*60]; <span class="comment">%Array for time values, seconds</span>
tau = [t(1) - t(2), 0, t(3) - t(2)]; <span class="comment">%Calculating time intervals</span>
T = tau(3) - tau(1);
</pre><h2 id="6">Calculate position R at the three times of the known satellite from known satellite orbital parameters</h2><pre class="codeinput">e_sat = 0;
a_sat = 8000;
Omega_sat = 0;
i_sat = 0;
omega_sat = 0;
anomaly = pi / 4;

[sat_orbit, R] = satellite(e_sat, a_sat, Omega_sat, omega_sat, i_sat, anomaly, t);

<span class="comment">%R = [5582.84, 0, 3073.9;...</span>
 <span class="comment">%   5581.5, 122.122, 3073.9;...</span>
  <span class="comment">%  5577.7, 244.186, 3073.9];</span>
<span class="comment">%Random position vectors to test algorithm</span>
</pre><h2 id="7">Determining unit vectors from satellite to unknown object</h2><pre class="codeinput">p = zeros(3); <span class="comment">%Creating array for direction cosine vectors at the three times</span>

<span class="comment">%For loop to calculate the direction cosine vectors at each time</span>
<span class="keyword">for</span> i = 1:3
    p(i,1) = cos(altitude(i)) * sin(azimuth(i));
    p(i,2) = cos(altitude(i)) * cos(azimuth(i));
    p(i,3) = sin(altitude(i));
<span class="keyword">end</span>

<span class="comment">%p = [.846428, 0, .532504;...</span>
 <span class="comment">%   .74929, .463023, .47347;...</span>
  <span class="comment">%  .529447, .777163, .340152];</span>
<span class="comment">% Random direction cosine vectors to test algorithm</span>
</pre><h2 id="8">Cross products among the direction cosine vectors</h2><pre class="codeinput">p1 = cross(p(2,:),p(3,:));
p2 = cross(p(1,:),p(3,:));
p3 = cross(p(1,:),p(2,:));

D0 = dot(p(1,:),p1);
</pre><h2 id="9">Computing the six scalar quantities</h2><pre class="codeinput">D = zeros(3);
<span class="keyword">for</span> q = 1:3
   D(q,1) = dot(R(q,:), p1);
   D(q,2) = dot(R(q,:), p2);
   D(q,3) = dot(R(q,:), p3);
<span class="keyword">end</span>
</pre><h2 id="10">Calculating A and B</h2><pre class="codeinput">A = (-D(1,2)*tau(3)/T + D(2,2) + D(3,2) * tau(1) / T) / D0;
B = (D(1,2)*(tau(3)^2 - T^2)*tau(3)/T + D(3,2)*(T^2 - tau(1)^2) * tau(1)/T)/(6 * D0);
</pre><h2 id="11">Calculating E</h2><pre class="codeinput">E = dot(R(2,:), p(2,:));
</pre><h2 id="12">Calculating a, b, and c</h2><pre class="codeinput">a = -(A^2 + 2*A*E + (norm(R(2,:)))^2);
b = -2*u*B*(A + E);
c = -(u^2 * B^2);
</pre><h2 id="13">Calculating the roots numerically</h2><pre class="codeinput">Roots = roots([1 0 a 0 0 b 0 0 c]);
x = posroot(Roots);
</pre><h2 id="14">Calculating the Lagrange coefficients</h2><pre class="codeinput">f1 = 1 - (u*tau(1)^2/x^3)/2;
f3 = 1 - (u*tau(3)^2/x^3)/2;

g1 = tau(1) - (u*(tau(1)/x)^3)/6;
g3 = tau(3) - (u*(tau(3)/x)^3)/6;
</pre><h2 id="15">Calculating position vector magnitudes from satellite to unknown object</h2><pre class="codeinput">P1 = 1/D0*((6*(D(3,1)*tau(1)/tau(3) + D(2,1)*T/tau(3))*x^3 + u*D(3,1)*(T^2 - tau(1)^2)*tau(1)/tau(3))/(6*x^3 + u*(T^2 - tau(3)^2)) - D(1,1));
P2 = A + u * B / x^3;
P3 = 1/D0*((6*(D(1,3)*tau(3)/tau(1) - D(2,3)*T/tau(1))*x^3 + u*D(1,3)*(T^2 - tau(3)^2)*tau(3)/tau(1))/(6*x^3 + u*(T^2 - tau(1)^2)) - D(3,3));
</pre><h2 id="16">Calculating position vectors from earth center to unknown object</h2><pre class="codeinput">r1 = R(1,:) + P1*p(1,:);
r2 = R(2,:) + P2*p(2,:);
r3 = R(3,:) + P3*p(3,:);
</pre><h2 id="17">Calculating velocity of unknown object</h2><pre class="codeinput">v2 = (1 / (f1*g3 - f3*g1))*(-f3*r1 + f1*r3);
</pre><h2 id="18">Method to improve accuracy of results taken from Curtis</h2><pre class="codeinput">P1_old = P1;  P2_old = P2;  P3_old = P3;
diff1    = 1;     diff2    = 1;     diff3    = 1;
n    = 0;
nmax = 2000;
tol  = 1.e-10;

<span class="comment">%...Iterative improvement loop from Curtis:</span>
<span class="keyword">while</span> ((diff1 &gt; tol) &amp;&amp; (diff2 &gt; tol) &amp;&amp; (diff3 &gt; tol)) &amp;&amp; (n &lt; nmax)
    n = n+1;

<span class="comment">%...Compute quantities required by universal kepler's equation:</span>
    ro  = norm(r2);
    vo  = norm(v2);
    vro = dot(v2,r2)/ro;
    alpha   = 2/ro - vo^2/u;

<span class="comment">%...Solve universal Kepler's equation at times tau1 and tau3 for</span>
<span class="comment">%   universal anomalies x1 and x3:</span>
    x1 = kepler_U(tau(1), ro, vro, alpha);
    x3 = kepler_U(tau(3), ro, vro, alpha);

<span class="comment">%...Calculate the Lagrange f and g coefficients at times tau1</span>
<span class="comment">%   and tau3:</span>
    [ff1, gg1] = f_and_g(x1, tau(1), ro, alpha);
    [ff3, gg3] = f_and_g(x3, tau(3), ro, alpha);

<span class="comment">%...Update the f and g functions at times tau1 and tau3 by</span>
<span class="comment">%   averaging old and new:</span>
    f1    = (f1 + ff1)/2;
    f3    = (f3 + ff3)/2;
    g1    = (g1 + gg1)/2;
    g3    = (g3 + gg3)/2;

<span class="comment">%...Equations 5.96 and 5.97:</span>
    c1    =  g3/(f1*g3 - f3*g1);
    c3    = -g1/(f1*g3 - f3*g1);

<span class="comment">%...Equations 5.109a, 5.110a and 5.111a:</span>
    P1  = 1/D0*(      -D(1,1) + 1/c1*D(2,1) - c3/c1*D(3,1));
    P2  = 1/D0*(   -c1*D(1,2) +      D(2,2) -    c3*D(3,2));
    P3  = 1/D0*(-c1/c3*D(1,3) + 1/c3*D(2,3) -       D(3,3));

<span class="comment">%...Equations 5.86:</span>
    r1 = R(1,:) + P1*p(1,:);
    r2 = R(2,:) + P2*p(2,:);
    r3 = R(3,:) + P3*p(3,:);

<span class="comment">%...Equation 5.118:</span>
    v2    = (-f3*r1 + f1*r3)/(f1*g3 - f3*g1);

<span class="comment">%...Calculate differences upon which to base convergence:</span>
    diff1 = abs(P1 - P1_old);
    diff2 = abs(P2 - P2_old);
    diff3 = abs(P3 - P3_old);

<span class="comment">%...Update the slant ranges:</span>
    P1_old = P1;  P2_old = P2;  P3_old = P3;
<span class="keyword">end</span>
<span class="comment">%...End iterative improvement loop</span>
</pre><h2 id="19">Determing orbit elements of unknown object from r2 and v2</h2><pre class="codeinput">[mag_e, a, theta, Omega, inc, omega] = orbit_elements(r2, v2);
</pre><h2 id="20">Plotting both orbits of known satellite and unknown object</h2><pre class="codeinput"><span class="keyword">if</span> (mag_e &lt; 1) &amp;&amp; (mag_e &gt; -1) <span class="comment">%Plotting only seems to work for elliptic orbits</span>
    <span class="comment">%Converting estimated orbital parameters to radians</span>
    W = Omega * deg_rad;
    w = omega * deg_rad;
    inclination = inc * deg_rad;

    <span class="comment">%Computing direction cosine matrix from perifocal to N for unknown object</span>
    C_N_PF_obj = [-sin(W)*cos(inclination)*sin(w)+cos(W)*cos(w), -sin(W)*cos(inclination)*cos(w)-cos(W)*sin(w), sin(W)*sin(inclination);<span class="keyword">...</span>
        cos(W)*cos(inclination)*sin(w)+sin(W)*cos(w), cos(W)*cos(inclination)*cos(w) - sin(W)*sin(w), sin(inclination)*cos(w);<span class="keyword">...</span>
        sin(inclination)*sin(w), sin(inclination)*cos(w), cos(inclination)];

    <span class="comment">%Magnitude of momentum for unknown object</span>
    h = norm(cross(r2, v2));

    <span class="comment">%For loop to calculate X,Y,Z positions of the estimated orbit</span>
    counter = 1;
    coordinate = zeros(3, 629);
    perogee = zeros(3, 1);
    <span class="keyword">for</span> angle = 0:.01:(2*pi)
        radius_polar = [h^2/(u * (1 + mag_e * cos(angle)));0;0];
        C_PF_polar_obj = [cos(angle), sin(angle), 0;<span class="keyword">...</span>
        -sin(angle), cos(angle), 0;<span class="keyword">...</span>
        0, 0, 1].';
       radius_pf = (C_PF_polar_obj * radius_polar);
       radius = (C_N_PF_obj * radius_pf).';
       <span class="keyword">for</span> z = 1:3
           coordinate(z, counter) = radius(z);
           <span class="keyword">if</span> angle == 0
            perogee(z, counter) = radius(z);
           <span class="keyword">end</span>
       <span class="keyword">end</span>
       counter = counter + 1;
    <span class="keyword">end</span>

    <span class="comment">%Plot the previously determined orbit</span>
    plot3(coordinate(1,:), coordinate(2,:), coordinate(3,:), <span class="string">'r'</span>)
    hold <span class="string">on</span>

    <span class="comment">%Plot the known orbit</span>
    plot3(sat_orbit(1,:), sat_orbit(2,:), sat_orbit(3,:), <span class="string">'b'</span>)

    <span class="comment">%Plot a sphere to represent the Earth</span>
    [xx, yy, zz] = sphere(100);
    lightGrey = 0.8*[1 1 1];
    surface(r_earth*xx, r_earth*yy, r_earth*zz, <span class="string">'FaceColor'</span>, <span class="string">'none'</span>, <span class="string">'EdgeColor'</span>, lightGrey);

    <span class="comment">%Draw and label the axes</span>
    line([0 3*r_earth],   [0 0],   [0 0]); text(3*r_earth+1000,   0,   0, <span class="string">'n_1'</span>)
    line(  [0 0], [0 3*r_earth],   [0 0]); text(  0, 3*r_earth+1000,   0, <span class="string">'n_2'</span>)
    line(  [0 0],   [0 0], [0 3*r_earth]); text(  0,   0, 3*r_earth+1000, <span class="string">'n_3'</span>)

    <span class="comment">%Draw line to perogee</span>
    line([0 perogee(1)], [0 perogee(2)], [0 perogee(3)], <span class="string">'Color'</span>, <span class="string">'k'</span>);
    text(perogee(1)*1.2, perogee(2)*1.2, perogee(3)*1.2, <span class="string">'Perogee'</span>)

    <span class="comment">%Draw line to each vector R of the known satellite at times</span>
    line([0 R(1,1)], [0 R(1,2)], [0 R(1, 3)], <span class="string">'Color'</span>, <span class="string">'k'</span>, <span class="string">'Linestyle'</span>, <span class="string">'-.'</span>)
    line([0 R(2,1)], [0 R(2,2)], [0 R(2, 3)], <span class="string">'Color'</span>, <span class="string">'k'</span>, <span class="string">'Linestyle'</span>, <span class="string">'-.'</span>)
    line([0 R(3,1)], [0 R(3,2)], [0 R(3, 3)], <span class="string">'Color'</span>, <span class="string">'k'</span>, <span class="string">'Linestyle'</span>, <span class="string">'-.'</span>)

    <span class="comment">%Miscellanious graph adjustments</span>
    grid <span class="string">on</span>
    axis <span class="string">equal</span>
    xlabel(<span class="string">'km'</span>)
    ylabel(<span class="string">'km'</span>)
    zlabel(<span class="string">'km'</span>)
    view(3)
    title(<span class="string">'Estimated Orbit Around Earth'</span>)
    legend(<span class="string">'Estimated Orbit'</span>, <span class="string">'Known Orbit'</span>)

    orbit = <span class="string">'elliptical'</span>; <span class="comment">%Specify orbit type based on eccentricity</span>
<span class="keyword">else</span>
    orbit = <span class="string">'hyperbolic'</span>; <span class="comment">%Specify orbit type based on eccentricity</span>
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="Project_01.png" alt=""> <h2 id="21">Ouputting parameters to Command Line</h2><pre class="codeinput">fprintf(<span class="string">'Estimated Orbital Parameters of the Unknown Object\n'</span>)
fprintf(<span class="string">'------------------------------------------------------------------'</span>)
fprintf(<span class="string">'\n Radius at point 2 [km] =                        %g n_1'</span>, r2(1))
fprintf(<span class="string">'\n                                                 %g n_2'</span>, r2(2))
fprintf(<span class="string">'\n                                                 %g n_3\n'</span>, r2(3))
fprintf(<span class="string">'\n Velocity at point 2 [km/s] =                    %g n_1'</span>, v2(1))
fprintf(<span class="string">'\n                                                 %g n_2'</span>, v2(2))
fprintf(<span class="string">'\n                                                 %g n_3\n'</span>, v2(3))
fprintf(<span class="string">'------------------------------------------------------------------'</span>)
fprintf(<span class="string">'\n Orbit is %s.'</span>, orbit)
fprintf(<span class="string">'\n Eccentricity =                                       %g'</span>, mag_e)
fprintf(<span class="string">'\n Semi-Major Axis [km] =                              %g'</span>, a)
fprintf(<span class="string">'\n Right of Ascension of the Ascending Node [degrees] = %g'</span>, Omega)
fprintf(<span class="string">'\n Inclination [degrees] =                              %g'</span>, inc)
fprintf(<span class="string">'\n Argument of Perogee [degrees] =                      %g'</span>, omega)
fprintf(<span class="string">'\n True Anomaly [degrees] =                             %g'</span>, theta)
fprintf(<span class="string">'\n'</span>)
</pre><pre class="codeoutput">Estimated Orbital Parameters of the Unknown Object
------------------------------------------------------------------
 Radius at point 2 [km] =                        5391.05 n_1
                                                 -4006.92 n_2
                                                 -563.775 n_3

 Velocity at point 2 [km/s] =                    4.7191 n_1
                                                 5.95546 n_2
                                                 -1.80436 n_3
------------------------------------------------------------------
 Orbit is elliptical.
 Eccentricity =                                       0.0584521
 Semi-Major Axis [km] =                              6959.53
 Right of Ascension of the Ascending Node [degrees] = 123.722
 Inclination [degrees] =                              14.0104
 Argument of Perogee [degrees] =                      139.888
 True Anomaly [degrees] =                             60.3224
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Spaceflight Mechanics - Semester Project - Spring 2019
% Angles Only Orbit Determination of Unknown Object from a Known Satellite
%% Administrative Remarks
%Author: Johnathan Corbin
%February 9, 2019
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%Assumptions made about the system:
% - The two body problem applies.
% - This system takes place around the Earth (u = 398600).
% - The Earth is a perfect sphere so as to ignore effects of precession.
% - I use the topocentric horizon reference frame on the spacecraft to
%    create the direction unit vectors to the unknown object from a given
%    altitude and azimuth angle seen from the spacecraft.
% - The timescale between angle measurements must be fairly small, think
%     several minutes, not hours.
% - The orbit of the satellite taking the measurements is known and that a
%      position vector can be made to that satellite at each instance when
%      an angle measurement is made.
% - Values of the estimated orbit are output at the end of the script, any
%      value that is a rotation value are in degrees, not radians.
% - When defininig the orbit of the known satellite, the satellite must be
%      in an elliptical orbit.
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%Derivations of the algorithm and some of the required functions were
%pulled from Orbital Mechanics for Engineering Students by Howard D.
%Curtis.
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%Required functions:
% f_and_g, improvement, kepler_E, kepler_U, orbit_elements,
% satellite, posroot, stumpC, stumpS
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
%% Clearing figures and command line
clear, clc
close all

%% Declaring constants
global u

u = 398600; %gravitational parameter for earth 
r_earth = 6378; %radius of earth
deg_rad = pi / 180; %converting degree to rad

%% Measured angle values
azimuth = [10, 89,  90] * deg_rad; %Azimuth angle of unknown object at times
altitude = [0, 20, 40] * deg_rad; %Altitude angle of unkown object at times

%% Time vectors
t = [0, 5*60, 10*60]; %Array for time values, seconds
tau = [t(1) - t(2), 0, t(3) - t(2)]; %Calculating time intervals
T = tau(3) - tau(1);

%% Calculate position R at the three times of the known satellite from known satellite orbital parameters
e_sat = 0;
a_sat = 8000;
Omega_sat = 0;
i_sat = 0;
omega_sat = 0;
anomaly = pi / 4;

[sat_orbit, R] = satellite(e_sat, a_sat, Omega_sat, omega_sat, i_sat, anomaly, t);

%R = [5582.84, 0, 3073.9;...
 %   5581.5, 122.122, 3073.9;...
  %  5577.7, 244.186, 3073.9];
%Random position vectors to test algorithm

%% Determining unit vectors from satellite to unknown object

p = zeros(3); %Creating array for direction cosine vectors at the three times

%For loop to calculate the direction cosine vectors at each time
for i = 1:3
    p(i,1) = cos(altitude(i)) * sin(azimuth(i));
    p(i,2) = cos(altitude(i)) * cos(azimuth(i));
    p(i,3) = sin(altitude(i));
end

%p = [.846428, 0, .532504;...
 %   .74929, .463023, .47347;...
  %  .529447, .777163, .340152];
% Random direction cosine vectors to test algorithm

%% Cross products among the direction cosine vectors
p1 = cross(p(2,:),p(3,:));
p2 = cross(p(1,:),p(3,:));
p3 = cross(p(1,:),p(2,:));

D0 = dot(p(1,:),p1);

%% Computing the six scalar quantities
D = zeros(3);
for q = 1:3
   D(q,1) = dot(R(q,:), p1);
   D(q,2) = dot(R(q,:), p2);
   D(q,3) = dot(R(q,:), p3);
end

%% Calculating A and B
A = (-D(1,2)*tau(3)/T + D(2,2) + D(3,2) * tau(1) / T) / D0;
B = (D(1,2)*(tau(3)^2 - T^2)*tau(3)/T + D(3,2)*(T^2 - tau(1)^2) * tau(1)/T)/(6 * D0);

%% Calculating E
E = dot(R(2,:), p(2,:));

%% Calculating a, b, and c
a = -(A^2 + 2*A*E + (norm(R(2,:)))^2);
b = -2*u*B*(A + E);
c = -(u^2 * B^2);

%% Calculating the roots numerically
Roots = roots([1 0 a 0 0 b 0 0 c]);
x = posroot(Roots);

%% Calculating the Lagrange coefficients
f1 = 1 - (u*tau(1)^2/x^3)/2;
f3 = 1 - (u*tau(3)^2/x^3)/2;

g1 = tau(1) - (u*(tau(1)/x)^3)/6;
g3 = tau(3) - (u*(tau(3)/x)^3)/6;

%% Calculating position vector magnitudes from satellite to unknown object
P1 = 1/D0*((6*(D(3,1)*tau(1)/tau(3) + D(2,1)*T/tau(3))*x^3 + u*D(3,1)*(T^2 - tau(1)^2)*tau(1)/tau(3))/(6*x^3 + u*(T^2 - tau(3)^2)) - D(1,1));
P2 = A + u * B / x^3;
P3 = 1/D0*((6*(D(1,3)*tau(3)/tau(1) - D(2,3)*T/tau(1))*x^3 + u*D(1,3)*(T^2 - tau(3)^2)*tau(3)/tau(1))/(6*x^3 + u*(T^2 - tau(1)^2)) - D(3,3));

%% Calculating position vectors from earth center to unknown object
r1 = R(1,:) + P1*p(1,:);
r2 = R(2,:) + P2*p(2,:);
r3 = R(3,:) + P3*p(3,:);

%% Calculating velocity of unknown object
v2 = (1 / (f1*g3 - f3*g1))*(-f3*r1 + f1*r3);
    
%% Method to improve accuracy of results taken from Curtis
P1_old = P1;  P2_old = P2;  P3_old = P3;
diff1    = 1;     diff2    = 1;     diff3    = 1;
n    = 0;
nmax = 2000;
tol  = 1.e-10;

%...Iterative improvement loop from Curtis:
while ((diff1 > tol) && (diff2 > tol) && (diff3 > tol)) && (n < nmax)
    n = n+1;

%...Compute quantities required by universal kepler's equation:
    ro  = norm(r2);
    vo  = norm(v2);
    vro = dot(v2,r2)/ro;
    alpha   = 2/ro - vo^2/u;

%...Solve universal Kepler's equation at times tau1 and tau3 for
%   universal anomalies x1 and x3:
    x1 = kepler_U(tau(1), ro, vro, alpha);
    x3 = kepler_U(tau(3), ro, vro, alpha);

%...Calculate the Lagrange f and g coefficients at times tau1
%   and tau3:
    [ff1, gg1] = f_and_g(x1, tau(1), ro, alpha);
    [ff3, gg3] = f_and_g(x3, tau(3), ro, alpha);

%...Update the f and g functions at times tau1 and tau3 by 
%   averaging old and new:
    f1    = (f1 + ff1)/2;
    f3    = (f3 + ff3)/2;
    g1    = (g1 + gg1)/2;
    g3    = (g3 + gg3)/2;

%...Equations 5.96 and 5.97:
    c1    =  g3/(f1*g3 - f3*g1);
    c3    = -g1/(f1*g3 - f3*g1);

%...Equations 5.109a, 5.110a and 5.111a:
    P1  = 1/D0*(      -D(1,1) + 1/c1*D(2,1) - c3/c1*D(3,1));
    P2  = 1/D0*(   -c1*D(1,2) +      D(2,2) -    c3*D(3,2));
    P3  = 1/D0*(-c1/c3*D(1,3) + 1/c3*D(2,3) -       D(3,3));

%...Equations 5.86:
    r1 = R(1,:) + P1*p(1,:);
    r2 = R(2,:) + P2*p(2,:);
    r3 = R(3,:) + P3*p(3,:);

%...Equation 5.118:
    v2    = (-f3*r1 + f1*r3)/(f1*g3 - f3*g1);

%...Calculate differences upon which to base convergence:
    diff1 = abs(P1 - P1_old);
    diff2 = abs(P2 - P2_old);
    diff3 = abs(P3 - P3_old);

%...Update the slant ranges:
    P1_old = P1;  P2_old = P2;  P3_old = P3;
end
%...End iterative improvement loop

%% Determing orbit elements of unknown object from r2 and v2
[mag_e, a, theta, Omega, inc, omega] = orbit_elements(r2, v2);
    
%% Plotting both orbits of known satellite and unknown object
if (mag_e < 1) && (mag_e > -1) %Plotting only seems to work for elliptic orbits
    %Converting estimated orbital parameters to radians
    W = Omega * deg_rad;
    w = omega * deg_rad;
    inclination = inc * deg_rad;

    %Computing direction cosine matrix from perifocal to N for unknown object
    C_N_PF_obj = [-sin(W)*cos(inclination)*sin(w)+cos(W)*cos(w), -sin(W)*cos(inclination)*cos(w)-cos(W)*sin(w), sin(W)*sin(inclination);...
        cos(W)*cos(inclination)*sin(w)+sin(W)*cos(w), cos(W)*cos(inclination)*cos(w) - sin(W)*sin(w), sin(inclination)*cos(w);...
        sin(inclination)*sin(w), sin(inclination)*cos(w), cos(inclination)];

    %Magnitude of momentum for unknown object
    h = norm(cross(r2, v2));

    %For loop to calculate X,Y,Z positions of the estimated orbit
    counter = 1;
    coordinate = zeros(3, 629);
    perogee = zeros(3, 1);
    for angle = 0:.01:(2*pi)
        radius_polar = [h^2/(u * (1 + mag_e * cos(angle)));0;0];
        C_PF_polar_obj = [cos(angle), sin(angle), 0;...
        -sin(angle), cos(angle), 0;...
        0, 0, 1].';
       radius_pf = (C_PF_polar_obj * radius_polar); 
       radius = (C_N_PF_obj * radius_pf).';
       for z = 1:3
           coordinate(z, counter) = radius(z);
           if angle == 0
            perogee(z, counter) = radius(z); 
           end
       end
       counter = counter + 1;
    end

    %Plot the previously determined orbit
    plot3(coordinate(1,:), coordinate(2,:), coordinate(3,:), 'r')
    hold on
    
    %Plot the known orbit
    plot3(sat_orbit(1,:), sat_orbit(2,:), sat_orbit(3,:), 'b')
    
    %Plot a sphere to represent the Earth
    [xx, yy, zz] = sphere(100);
    lightGrey = 0.8*[1 1 1];
    surface(r_earth*xx, r_earth*yy, r_earth*zz, 'FaceColor', 'none', 'EdgeColor', lightGrey);

    %Draw and label the axes
    line([0 3*r_earth],   [0 0],   [0 0]); text(3*r_earth+1000,   0,   0, 'n_1')
    line(  [0 0], [0 3*r_earth],   [0 0]); text(  0, 3*r_earth+1000,   0, 'n_2')
    line(  [0 0],   [0 0], [0 3*r_earth]); text(  0,   0, 3*r_earth+1000, 'n_3')

    %Draw line to perogee
    line([0 perogee(1)], [0 perogee(2)], [0 perogee(3)], 'Color', 'k'); 
    text(perogee(1)*1.2, perogee(2)*1.2, perogee(3)*1.2, 'Perogee')
    
    %Draw line to each vector R of the known satellite at times
    line([0 R(1,1)], [0 R(1,2)], [0 R(1, 3)], 'Color', 'k', 'Linestyle', '-.')
    line([0 R(2,1)], [0 R(2,2)], [0 R(2, 3)], 'Color', 'k', 'Linestyle', '-.')
    line([0 R(3,1)], [0 R(3,2)], [0 R(3, 3)], 'Color', 'k', 'Linestyle', '-.')
    
    %Miscellanious graph adjustments
    grid on
    axis equal
    xlabel('km')
    ylabel('km')
    zlabel('km')
    view(3)
    title('Estimated Orbit Around Earth')
    legend('Estimated Orbit', 'Known Orbit')
    
    orbit = 'elliptical'; %Specify orbit type based on eccentricity
else 
    orbit = 'hyperbolic'; %Specify orbit type based on eccentricity
end

%% Ouputting parameters to Command Line
fprintf('Estimated Orbital Parameters of the Unknown Object\n')
fprintf('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
fprintf('\n Radius at point 2 [km] =                        %g n_1', r2(1))
fprintf('\n                                                 %g n_2', r2(2))
fprintf('\n                                                 %g n_3\n', r2(3))
fprintf('\n Velocity at point 2 [km/s] =                    %g n_1', v2(1))
fprintf('\n                                                 %g n_2', v2(2))
fprintf('\n                                                 %g n_3\n', v2(3))
fprintf('REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH')
fprintf('\n Orbit is %s.', orbit)
fprintf('\n Eccentricity =                                       %g', mag_e)
fprintf('\n Semi-Major Axis [km] =                              %g', a)
fprintf('\n Right of Ascension of the Ascending Node [degrees] = %g', Omega)
fprintf('\n Inclination [degrees] =                              %g', inc)
fprintf('\n Argument of Perogee [degrees] =                      %g', omega)
fprintf('\n True Anomaly [degrees] =                             %g', theta)
fprintf('\n')
##### SOURCE END #####
--></body></html>